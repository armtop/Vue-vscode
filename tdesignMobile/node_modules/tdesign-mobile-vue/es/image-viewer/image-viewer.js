/**
 * tdesign v1.2.3
 * (c) 2024 TDesign Group
 * @license MIT
 */

import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { defineComponent, Transition, getCurrentInstance, reactive, ref, computed, h, nextTick, watch, onUnmounted, toRefs, resolveComponent, openBlock, createBlock, withCtx, createElementBlock, normalizeClass, createElementVNode, createVNode, Fragment, renderList, normalizeStyle, withModifiers, createCommentVNode, toDisplayString } from 'vue';
import { CloseIcon, DeleteIcon } from 'tdesign-icons-vue-next';
import config from '../config.js';
import ImagediverProps from './props.js';
import '../shared/index.js';
import { Swiper, SwiperItem } from '../swiper/index.js';
import _Image from '../image/index.js';
import TNodeComponent from '../shared/render-tnode.js';
import { useDefault } from '../shared/useDefault/index.js';
import { renderTNode } from '../shared/render.js';
import { isBrowser } from '../shared/util.js';
import { useGesture } from '../shared/useGesture/index.js';
import '../shared/functions.js';
import '../shared/component.js';
import '../shared/constants.js';
import '../shared/useToggle/index.js';
import '../shared/useCountDown/index.js';
import '@babel/runtime/helpers/asyncToGenerator';
import '@babel/runtime/regenerator';
import '@vueuse/core';
import '../shared/useCountDown/utils.js';
import '../shared/useChildSlots/index.js';
import '@babel/runtime/helpers/toConsumableArray';
import '../shared/useVModel/index.js';
import 'lodash/kebabCase';
import '../shared/useTouch/index.js';
import '../shared/useScrollParent/index.js';
import '../shared/useExpose/index.js';
import '../shared/useTest/index.js';
import '../shared/useClickAway/index.js';
import 'lodash/isArray';
import '../shared/hover.js';
import 'lodash/isNumber';
import '@babel/runtime/helpers/typeof';
import 'lodash/camelCase';
import '@use-gesture/vanilla';
import 'lodash/isObject';
import '../swipe-cell/useSwipe.js';
import '../shared/dom.js';
import 'lodash/isFunction';
import 'lodash/isString';
import '../swiper/props.js';
import '../hooks/tnode.js';
import '../hooks/render-tnode.js';
import 'lodash/isEmpty';
import '../hooks/useClass.js';
import '../config-provider/useConfig.js';
import 'lodash/cloneDeep';
import '../config-provider/context.js';
import 'lodash/mergeWith';
import 'lodash/merge';
import '../_common/js/global-config/mobile/default-config.js';
import '../_common/js/global-config/mobile/locale/zh_CN.js';
import '../_chunks/dep-4c6045f6.js';
import '../_chunks/dep-1d280204.js';
import 'dayjs';
import '../_chunks/dep-5101c61a.js';
import '../config-provider/type.js';
import './style/css.js';
import '../swiper/type.js';
import '../image/image.js';
import '../loading/index.js';
import '../_common/js/loading/circle-adapter.js';
import '../_common/js/utils/set-style.js';
import '../_common/js/utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import 'lodash/isNull';
import 'lodash/isUndefined';
import '../loading/props.js';
import '../loading/type.js';
import '../image/props.js';
import '../image/type.js';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var prefix = config.prefix;
var name = "".concat(prefix, "-image-viewer");
var TAP_TIME = 300;
var script = defineComponent({
  name: name,
  components: {
    Transition: Transition,
    TSwiper: Swiper,
    TSwiperItem: SwiperItem,
    TNode: TNodeComponent,
    TImage: _Image
  },
  props: ImagediverProps,
  emits: ["close", "index-change", "update:visible", "update:modelValue", "update:index", "delete"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var internalInstance = getCurrentInstance();
    var state = reactive({
      dblTapZooming: false,
      zooming: false,
      scale: 1,
      touchIndex: 0,
      dragging: false,
      draggedX: 0,
      draggedY: 0,
      extraDraggedX: 0
    });
    var _useDefault = useDefault(props, emit, "visible", "change"),
      _useDefault2 = _slicedToArray(_useDefault, 2),
      visible = _useDefault2[0],
      setVisible = _useDefault2[1];
    var _useDefault3 = useDefault(props, emit, "index", "index-change"),
      _useDefault4 = _slicedToArray(_useDefault3, 2),
      currentIndex = _useDefault4[0],
      setIndex = _useDefault4[1];
    var disabled = ref(false);
    var rootRef = ref();
    var imagesSize = reactive({});
    var swiperRootRef = ref();
    var swiperItemRefs = ref();
    var gestureRef = ref();
    var closeNode = computed(function () {
      return renderTNode(internalInstance, "close-btn", {
        defaultNode: h(CloseIcon)
      });
    });
    var deleteNode = computed(function () {
      return renderTNode(internalInstance, "delete-btn", {
        defaultNode: h(DeleteIcon)
      });
    });
    var imageTransform = computed(function () {
      var scale = state.scale,
        draggedX = state.draggedX,
        draggedY = state.draggedY;
      return "matrix(".concat(scale, ", 0, 0, ").concat(scale, ", ").concat(draggedX, ", ").concat(draggedY, ")");
    });
    var imageTransitionDuration = computed(function () {
      var zooming = state.zooming,
        dragging = state.dragging;
      return zooming || dragging ? "transition-duration: 0s" : "transition-duration: 0.3s";
    });
    var beforeClose = function beforeClose() {
      state.dblTapZooming = false;
      state.zooming = false;
      state.scale = 1;
      state.dragging = false;
      state.draggedX = 0;
      state.draggedY = 0;
      state.extraDraggedX = 0;
    };
    var handleClose = function handleClose(e, trigger) {
      beforeClose();
      setVisible(false);
      emit("close", {
        trigger: trigger,
        e: e
      });
    };
    var handleDelete = function handleDelete() {
      var _currentIndex$value;
      emit("delete", (_currentIndex$value = currentIndex.value) !== null && _currentIndex$value !== void 0 ? _currentIndex$value : 0);
    };
    var onSwiperChange = function onSwiperChange(index, context) {
      if (currentIndex.value !== index) {
        setIndex(index, {
          context: context
        });
        setScale(1);
      }
    };
    var onImgLoad = function onImgLoad(e, index) {
      var height = e.target.height;
      imagesSize[index] = {
        height: height
      };
    };
    var getMaxDraggedX = function getMaxDraggedX() {
      var _rootRef$value;
      var rootOffsetWidth = ((_rootRef$value = rootRef.value) === null || _rootRef$value === void 0 ? void 0 : _rootRef$value.offsetWidth) || 0;
      var scaledWidth = state.scale * rootOffsetWidth;
      return Math.max(0, (scaledWidth - rootOffsetWidth) / 2);
    };
    var getMaxDraggedY = function getMaxDraggedY(index) {
      var _rootRef$value2, _imagesSize$index;
      var rootOffsetHeight = ((_rootRef$value2 = rootRef.value) === null || _rootRef$value2 === void 0 ? void 0 : _rootRef$value2.offsetHeight) || 0;
      var currentImageScaledHeight = state.scale * ((imagesSize === null || imagesSize === void 0 || (_imagesSize$index = imagesSize[index]) === null || _imagesSize$index === void 0 ? void 0 : _imagesSize$index.height) || 0);
      if (currentImageScaledHeight <= rootOffsetHeight) return 0;
      return Math.max(0, (currentImageScaledHeight - rootOffsetHeight) / 2);
    };
    var setScale = function setScale(scale) {
      scale = Math.min(scale, +props.maxZoom + 1);
      if (scale !== state.scale) {
        state.scale = scale;
        if (scale === 1) {
          state.draggedX = 0;
          state.draggedY = 0;
        }
      }
    };
    var dragStartTime;
    var dblTapTimer;
    var toggleScale = function toggleScale() {
      var scale = state.scale > 1 ? 1 : 2;
      setScale(scale);
    };
    var onTransitionEnd = function onTransitionEnd(index) {
      if (index === state.touchIndex) {
        state.dblTapZooming = false;
        clearTimeout(dblTapTimer);
        dblTapTimer = null;
      }
    };
    var onTransitionStart = function onTransitionStart(index) {
      if (index === state.touchIndex) {
        state.dblTapZooming = true;
        clearTimeout(dblTapTimer);
      }
    };
    var checkTap = function checkTap(e) {
      var event = e.event;
      var deltaTime = Date.now() - dragStartTime;
      if (deltaTime < TAP_TIME && isBrowser) {
        if (dblTapTimer) {
          clearTimeout(dblTapTimer);
          dblTapTimer = window.setTimeout(function () {
            clearTimeout(dblTapTimer);
            state.dragging = false;
            toggleScale();
          }, TAP_TIME);
        } else {
          dblTapTimer = window.setTimeout(function () {
            handleClose(event, "overlay");
            dblTapTimer = null;
          }, TAP_TIME);
        }
      }
    };
    var onPinchChange = function onPinchChange(scale, index) {
      state.zooming = true;
      state.touchIndex = index;
      setScale(scale);
    };
    var onPinchEnd = function onPinchEnd() {
      state.zooming = false;
      if (state.scale < 1) {
        setScale(1);
      }
      if (state.scale > props.maxZoom) {
        state.scale = +props.maxZoom;
      }
    };
    var handlePinch = function handlePinch(pinState, index) {
      var last = pinState.last,
        _pinState$offset = _slicedToArray(pinState.offset, 1),
        d = _pinState$offset[0];
      if (!(imagesSize !== null && imagesSize !== void 0 && imagesSize[index])) return;
      if (state.dblTapZooming) return;
      if (!last) {
        onPinchChange(d, index);
      } else {
        onPinchEnd();
      }
    };
    var handleDrag = function handleDrag(dragState, index) {
      state.touchIndex = index;
      var _ref2 = swiperRootRef.value || {},
        setOffset = _ref2.setOffset;
      if (!(imagesSize !== null && imagesSize !== void 0 && imagesSize[index])) return;
      var first = dragState.first,
        movement = dragState.movement,
        _movement = dragState._movement,
        elapsedTime = dragState.elapsedTime,
        tap = dragState.tap,
        offset = dragState.offset,
        overflow = dragState.overflow,
        _delta = dragState._delta;
      if (first) {
        dragStartTime = Date.now();
      }
      if (tap && elapsedTime > 0 && elapsedTime < 300) {
        checkTap(dragState);
        return;
      }
      if (state.dblTapZooming) {
        dragState === null || dragState === void 0 || dragState.cancel();
        return;
      }
      state.dragging = true;
      state.draggedY = (offset === null || offset === void 0 ? void 0 : offset[1]) || 0;
      if (state.scale === 1) return;
      state.draggedX = (offset === null || offset === void 0 ? void 0 : offset[0]) || 0;
      if (movement[0] !== _movement[0] && overflow[0] !== 0) {
        state.extraDraggedX += _delta[0] / 5;
        setOffset === null || setOffset === void 0 || setOffset(state.extraDraggedX, "X");
      } else if (state.extraDraggedX !== 0) {
        state.extraDraggedX = 0;
        setOffset === null || setOffset === void 0 || setOffset(state.extraDraggedX, "X");
      }
    };
    var handleDragEnd = function handleDragEnd(dragState) {
      var overflow = dragState.overflow,
        last = dragState.last;
      var _ref3 = swiperRootRef.value || {},
        goPrev = _ref3.goPrev,
        goNext = _ref3.goNext,
        swiperContainer = _ref3.swiperContainer;
      state.dragging = false;
      if (state.extraDraggedX !== 0 && last) {
        if (Math.abs(state.extraDraggedX) > 50) {
          state.extraDraggedX = 0;
          overflow[0] < 0 ? goNext === null || goNext === void 0 ? void 0 : goNext("touch") : goPrev === null || goPrev === void 0 ? void 0 : goPrev("touch");
          return;
        }
        state.extraDraggedX = 0;
        nextTick(function () {
          var _swiperContainer$styl, _swiperContainer$styl2, _swiperContainer$styl3, _swiperContainer$styl4;
          swiperContainer === null || swiperContainer === void 0 || (_swiperContainer$styl = swiperContainer.style) === null || _swiperContainer$styl === void 0 || (_swiperContainer$styl2 = _swiperContainer$styl.setProperty) === null || _swiperContainer$styl2 === void 0 || _swiperContainer$styl2.call(_swiperContainer$styl, "transform", "translateX(0)");
          swiperContainer === null || swiperContainer === void 0 || (_swiperContainer$styl3 = swiperContainer.style) === null || _swiperContainer$styl3 === void 0 || (_swiperContainer$styl4 = _swiperContainer$styl3.setProperty) === null || _swiperContainer$styl4 === void 0 || _swiperContainer$styl4.call(_swiperContainer$styl3, "transition", "transform 0.3s");
        });
      }
    };
    var gestureOptions = reactive({
      destroyInvisible: true,
      visible: !!visible.value
    });
    gestureRef.value = useGesture(gestureOptions);
    watch(function () {
      return visible.value;
    }, function (newVal) {
      return gestureOptions.visible = !!newVal;
    });
    watch(function () {
      return [visible.value, swiperItemRefs.value];
    }, function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        newVisible = _ref5[0],
        newRefs = _ref5[1];
      if (!newVisible) return;
      nextTick(function () {
        var _newRefs$forEach;
        newRefs === null || newRefs === void 0 || (_newRefs$forEach = newRefs.forEach) === null || _newRefs$forEach === void 0 || _newRefs$forEach.call(newRefs, function (item, index) {
          var _gestureRef$value;
          var $el = item.$el;
          (_gestureRef$value = gestureRef.value) === null || _gestureRef$value === void 0 || _gestureRef$value.create($el, {
            onDrag: function onDrag(dragState) {
              return handleDrag(dragState, index);
            },
            onDragEnd: function onDragEnd(dragState) {
              return handleDragEnd(dragState);
            },
            onPinch: function onPinch(pinchState) {
              return handlePinch(pinchState, index);
            }
          }, {
            drag: {
              from: function from() {
                return [state.draggedX, state.draggedY];
              },
              pointer: {
                touch: true
              },
              bounds: function bounds() {
                return {
                  top: -getMaxDraggedY(index),
                  right: getMaxDraggedX(),
                  bottom: getMaxDraggedY(index),
                  left: -getMaxDraggedX()
                };
              }
            },
            pinch: {
              from: function from() {
                return [state.scale, 0];
              },
              pointer: {
                touch: true
              }
            }
          });
        });
      });
    });
    watch(function () {
      return state.scale;
    }, function (newVal) {
      return disabled.value = newVal !== 1;
    });
    onUnmounted(function () {
      clearTimeout(dblTapTimer);
    });
    return _objectSpread(_objectSpread({
      swiperRootRef: swiperRootRef,
      swiperItemRefs: swiperItemRefs,
      rootRef: rootRef,
      disabled: disabled,
      name: name
    }, toRefs(state)), {}, {
      prefix: prefix,
      closeNode: closeNode,
      deleteNode: deleteNode,
      currentIndex: currentIndex,
      imageTransform: imageTransform,
      imageTransitionDuration: imageTransitionDuration,
      visible: visible,
      handleClose: handleClose,
      handleDelete: handleDelete,
      onSwiperChange: onSwiperChange,
      onImgLoad: onImgLoad,
      onTransitionEnd: onTransitionEnd,
      onTransitionStart: onTransitionStart
    });
  }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_t_image = resolveComponent("t-image");
  var _component_t_swiper_item = resolveComponent("t-swiper-item");
  var _component_t_swiper = resolveComponent("t-swiper");
  var _component_t_node = resolveComponent("t-node");
  return openBlock(), createBlock(Transition, {
    name: "fade"
  }, {
    default: withCtx(function () {
      var _ctx$currentIndex, _ctx$images, _ctx$images2;
      return [_ctx.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: function ref(el) {
          return _ctx.rootRef = el;
        },
        class: normalizeClass("".concat(_ctx.prefix, "-image-viewer"))
      }, [createElementVNode("div", {
        class: normalizeClass("".concat(_ctx.name, "__mask")),
        onClick: _cache[0] || (_cache[0] = function ($event) {
          return _ctx.handleClose($event, "overlay");
        })
      }, null, 2), createVNode(_component_t_swiper, {
        ref: "swiperRootRef",
        autoplay: false,
        class: normalizeClass("".concat(_ctx.name, "__content")),
        height: "100vh",
        "default-current": _ctx.currentIndex,
        disabled: _ctx.disabled,
        onChange: _ctx.onSwiperChange
      }, {
        default: withCtx(function () {
          return [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.images, function (image, index) {
            return openBlock(), createBlock(_component_t_swiper_item, {
              ref_for: true,
              ref: "swiperItemRefs",
              key: index,
              class: normalizeClass("".concat(_ctx.name, "__swiper-item")),
              style: {
                "touch-action": "none"
              }
            }, {
              default: withCtx(function () {
                return [createVNode(_component_t_image, {
                  src: image,
                  style: normalizeStyle("".concat(_ctx.imageTransitionDuration, "; ").concat(index === _ctx.touchIndex ? "transform: ".concat(_ctx.imageTransform) : "transform: matrix(1, 0, 0, 1, 0, 0)")),
                  "on-load": function onLoad(_ref) {
                    var e = _ref.e;
                    return _ctx.onImgLoad(e, index);
                  },
                  onTransitionend: withModifiers(function ($event) {
                    return _ctx.onTransitionEnd(index);
                  }, ["self"]),
                  onTransitionstart: withModifiers(function ($event) {
                    return _ctx.onTransitionStart(index);
                  }, ["self"])
                }, null, 8, ["src", "style", "on-load", "onTransitionend", "onTransitionstart"])];
              }),
              _: 2
            }, 1032, ["class"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["class", "default-current", "disabled", "onChange"]), createElementVNode("div", {
        class: normalizeClass("".concat(_ctx.name, "__nav"))
      }, [_ctx.closeNode ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass("".concat(_ctx.name, "__nav-close")),
        onClick: _cache[1] || (_cache[1] = function ($event) {
          return _ctx.handleClose($event, "close-btn");
        })
      }, [createVNode(_component_t_node, {
        content: _ctx.closeNode
      }, null, 8, ["content"])], 2)) : createCommentVNode("", true), _ctx.showIndex ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass("".concat(_ctx.name, "__nav-index"))
      }, toDisplayString(Math.min(((_ctx$currentIndex = _ctx.currentIndex) !== null && _ctx$currentIndex !== void 0 ? _ctx$currentIndex : 0) + 1, (_ctx$images = _ctx.images) === null || _ctx$images === void 0 ? void 0 : _ctx$images.length)) + "/" + toDisplayString((_ctx$images2 = _ctx.images) === null || _ctx$images2 === void 0 ? void 0 : _ctx$images2.length), 3)) : createCommentVNode("", true), _ctx.deleteNode ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass("".concat(_ctx.name, "__nav-delete")),
        onClick: _cache[2] || (_cache[2] = function () {
          return _ctx.handleDelete && _ctx.handleDelete.apply(_ctx, arguments);
        })
      }, [createVNode(_component_t_node, {
        content: _ctx.deleteNode
      }, null, 8, ["content"])], 2)) : createCommentVNode("", true)], 2)], 2)) : createCommentVNode("", true)];
    }),
    _: 1
  });
}

script.render = render;

export { script as default };
//# sourceMappingURL=image-viewer.js.map
