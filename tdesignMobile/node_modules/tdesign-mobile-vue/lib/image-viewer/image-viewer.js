/**
 * tdesign v1.2.3
 * (c) 2024 TDesign Group
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var vue = require('vue');
var tdesignIconsVueNext = require('tdesign-icons-vue-next');
var config = require('../config.js');
var imageViewer_props = require('./props.js');
var swiper_index = require('../swiper/index.js');
var image_index = require('../image/index.js');
var shared_renderTnode = require('../shared/render-tnode.js');
var shared_useGesture_index = require('../shared/useGesture/index.js');
var shared_useDefault_index = require('../shared/useDefault/index.js');
var shared_render = require('../shared/render.js');
var shared_util = require('../shared/util.js');
require('@babel/runtime/helpers/typeof');
require('lodash/isObject');
require('lodash/isNumber');
require('../swipe-cell/useSwipe.js');
require('@vueuse/core');
require('../shared/dom.js');
require('lodash/isFunction');
require('lodash/isString');
require('../swiper/props.js');
require('../hooks/tnode.js');
require('lodash/camelCase');
require('lodash/kebabCase');
require('../hooks/render-tnode.js');
require('lodash/isEmpty');
require('../hooks/useClass.js');
require('../config-provider/useConfig.js');
require('lodash/cloneDeep');
require('../config-provider/context.js');
require('lodash/mergeWith');
require('lodash/merge');
require('lodash/isArray');
require('../_common/js/global-config/mobile/default-config.js');
require('../_common/js/global-config/mobile/locale/zh_CN.js');
require('../_chunks/dep-191173f8.js');
require('../_chunks/dep-2088457f.js');
require('dayjs');
require('../shared/useVModel/index.js');
require('../shared/component.js');
require('../image/image.js');
require('../loading/index.js');
require('../_common/js/loading/circle-adapter.js');
require('../_common/js/utils/set-style.js');
require('../_common/js/utils/helper.js');
require('@babel/runtime/helpers/toConsumableArray');
require('@babel/runtime/helpers/objectWithoutProperties');
require('lodash/isNull');
require('lodash/isUndefined');
require('../loading/props.js');
require('../image/props.js');
require('@use-gesture/vanilla');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var prefix = config["default"].prefix;
var name = "".concat(prefix, "-image-viewer");
var TAP_TIME = 300;
var script = vue.defineComponent({
  name: name,
  components: {
    Transition: vue.Transition,
    TSwiper: swiper_index.Swiper,
    TSwiperItem: swiper_index.SwiperItem,
    TNode: shared_renderTnode["default"],
    TImage: image_index["default"]
  },
  props: imageViewer_props["default"],
  emits: ["close", "index-change", "update:visible", "update:modelValue", "update:index", "delete"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var internalInstance = vue.getCurrentInstance();
    var state = vue.reactive({
      dblTapZooming: false,
      zooming: false,
      scale: 1,
      touchIndex: 0,
      dragging: false,
      draggedX: 0,
      draggedY: 0,
      extraDraggedX: 0
    });
    var _useDefault = shared_useDefault_index.useDefault(props, emit, "visible", "change"),
      _useDefault2 = _slicedToArray__default["default"](_useDefault, 2),
      visible = _useDefault2[0],
      setVisible = _useDefault2[1];
    var _useDefault3 = shared_useDefault_index.useDefault(props, emit, "index", "index-change"),
      _useDefault4 = _slicedToArray__default["default"](_useDefault3, 2),
      currentIndex = _useDefault4[0],
      setIndex = _useDefault4[1];
    var disabled = vue.ref(false);
    var rootRef = vue.ref();
    var imagesSize = vue.reactive({});
    var swiperRootRef = vue.ref();
    var swiperItemRefs = vue.ref();
    var gestureRef = vue.ref();
    var closeNode = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "close-btn", {
        defaultNode: vue.h(tdesignIconsVueNext.CloseIcon)
      });
    });
    var deleteNode = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "delete-btn", {
        defaultNode: vue.h(tdesignIconsVueNext.DeleteIcon)
      });
    });
    var imageTransform = vue.computed(function () {
      var scale = state.scale,
        draggedX = state.draggedX,
        draggedY = state.draggedY;
      return "matrix(".concat(scale, ", 0, 0, ").concat(scale, ", ").concat(draggedX, ", ").concat(draggedY, ")");
    });
    var imageTransitionDuration = vue.computed(function () {
      var zooming = state.zooming,
        dragging = state.dragging;
      return zooming || dragging ? "transition-duration: 0s" : "transition-duration: 0.3s";
    });
    var beforeClose = function beforeClose() {
      state.dblTapZooming = false;
      state.zooming = false;
      state.scale = 1;
      state.dragging = false;
      state.draggedX = 0;
      state.draggedY = 0;
      state.extraDraggedX = 0;
    };
    var handleClose = function handleClose(e, trigger) {
      beforeClose();
      setVisible(false);
      emit("close", {
        trigger: trigger,
        e: e
      });
    };
    var handleDelete = function handleDelete() {
      var _currentIndex$value;
      emit("delete", (_currentIndex$value = currentIndex.value) !== null && _currentIndex$value !== void 0 ? _currentIndex$value : 0);
    };
    var onSwiperChange = function onSwiperChange(index, context) {
      if (currentIndex.value !== index) {
        setIndex(index, {
          context: context
        });
        setScale(1);
      }
    };
    var onImgLoad = function onImgLoad(e, index) {
      var height = e.target.height;
      imagesSize[index] = {
        height: height
      };
    };
    var getMaxDraggedX = function getMaxDraggedX() {
      var _rootRef$value;
      var rootOffsetWidth = ((_rootRef$value = rootRef.value) === null || _rootRef$value === void 0 ? void 0 : _rootRef$value.offsetWidth) || 0;
      var scaledWidth = state.scale * rootOffsetWidth;
      return Math.max(0, (scaledWidth - rootOffsetWidth) / 2);
    };
    var getMaxDraggedY = function getMaxDraggedY(index) {
      var _rootRef$value2, _imagesSize$index;
      var rootOffsetHeight = ((_rootRef$value2 = rootRef.value) === null || _rootRef$value2 === void 0 ? void 0 : _rootRef$value2.offsetHeight) || 0;
      var currentImageScaledHeight = state.scale * ((imagesSize === null || imagesSize === void 0 || (_imagesSize$index = imagesSize[index]) === null || _imagesSize$index === void 0 ? void 0 : _imagesSize$index.height) || 0);
      if (currentImageScaledHeight <= rootOffsetHeight) return 0;
      return Math.max(0, (currentImageScaledHeight - rootOffsetHeight) / 2);
    };
    var setScale = function setScale(scale) {
      scale = Math.min(scale, +props.maxZoom + 1);
      if (scale !== state.scale) {
        state.scale = scale;
        if (scale === 1) {
          state.draggedX = 0;
          state.draggedY = 0;
        }
      }
    };
    var dragStartTime;
    var dblTapTimer;
    var toggleScale = function toggleScale() {
      var scale = state.scale > 1 ? 1 : 2;
      setScale(scale);
    };
    var onTransitionEnd = function onTransitionEnd(index) {
      if (index === state.touchIndex) {
        state.dblTapZooming = false;
        clearTimeout(dblTapTimer);
        dblTapTimer = null;
      }
    };
    var onTransitionStart = function onTransitionStart(index) {
      if (index === state.touchIndex) {
        state.dblTapZooming = true;
        clearTimeout(dblTapTimer);
      }
    };
    var checkTap = function checkTap(e) {
      var event = e.event;
      var deltaTime = Date.now() - dragStartTime;
      if (deltaTime < TAP_TIME && shared_util.isBrowser) {
        if (dblTapTimer) {
          clearTimeout(dblTapTimer);
          dblTapTimer = window.setTimeout(function () {
            clearTimeout(dblTapTimer);
            state.dragging = false;
            toggleScale();
          }, TAP_TIME);
        } else {
          dblTapTimer = window.setTimeout(function () {
            handleClose(event, "overlay");
            dblTapTimer = null;
          }, TAP_TIME);
        }
      }
    };
    var onPinchChange = function onPinchChange(scale, index) {
      state.zooming = true;
      state.touchIndex = index;
      setScale(scale);
    };
    var onPinchEnd = function onPinchEnd() {
      state.zooming = false;
      if (state.scale < 1) {
        setScale(1);
      }
      if (state.scale > props.maxZoom) {
        state.scale = +props.maxZoom;
      }
    };
    var handlePinch = function handlePinch(pinState, index) {
      var last = pinState.last,
        _pinState$offset = _slicedToArray__default["default"](pinState.offset, 1),
        d = _pinState$offset[0];
      if (!(imagesSize !== null && imagesSize !== void 0 && imagesSize[index])) return;
      if (state.dblTapZooming) return;
      if (!last) {
        onPinchChange(d, index);
      } else {
        onPinchEnd();
      }
    };
    var handleDrag = function handleDrag(dragState, index) {
      state.touchIndex = index;
      var _ref2 = swiperRootRef.value || {},
        setOffset = _ref2.setOffset;
      if (!(imagesSize !== null && imagesSize !== void 0 && imagesSize[index])) return;
      var first = dragState.first,
        movement = dragState.movement,
        _movement = dragState._movement,
        elapsedTime = dragState.elapsedTime,
        tap = dragState.tap,
        offset = dragState.offset,
        overflow = dragState.overflow,
        _delta = dragState._delta;
      if (first) {
        dragStartTime = Date.now();
      }
      if (tap && elapsedTime > 0 && elapsedTime < 300) {
        checkTap(dragState);
        return;
      }
      if (state.dblTapZooming) {
        dragState === null || dragState === void 0 || dragState.cancel();
        return;
      }
      state.dragging = true;
      state.draggedY = (offset === null || offset === void 0 ? void 0 : offset[1]) || 0;
      if (state.scale === 1) return;
      state.draggedX = (offset === null || offset === void 0 ? void 0 : offset[0]) || 0;
      if (movement[0] !== _movement[0] && overflow[0] !== 0) {
        state.extraDraggedX += _delta[0] / 5;
        setOffset === null || setOffset === void 0 || setOffset(state.extraDraggedX, "X");
      } else if (state.extraDraggedX !== 0) {
        state.extraDraggedX = 0;
        setOffset === null || setOffset === void 0 || setOffset(state.extraDraggedX, "X");
      }
    };
    var handleDragEnd = function handleDragEnd(dragState) {
      var overflow = dragState.overflow,
        last = dragState.last;
      var _ref3 = swiperRootRef.value || {},
        goPrev = _ref3.goPrev,
        goNext = _ref3.goNext,
        swiperContainer = _ref3.swiperContainer;
      state.dragging = false;
      if (state.extraDraggedX !== 0 && last) {
        if (Math.abs(state.extraDraggedX) > 50) {
          state.extraDraggedX = 0;
          overflow[0] < 0 ? goNext === null || goNext === void 0 ? void 0 : goNext("touch") : goPrev === null || goPrev === void 0 ? void 0 : goPrev("touch");
          return;
        }
        state.extraDraggedX = 0;
        vue.nextTick(function () {
          var _swiperContainer$styl, _swiperContainer$styl2, _swiperContainer$styl3, _swiperContainer$styl4;
          swiperContainer === null || swiperContainer === void 0 || (_swiperContainer$styl = swiperContainer.style) === null || _swiperContainer$styl === void 0 || (_swiperContainer$styl2 = _swiperContainer$styl.setProperty) === null || _swiperContainer$styl2 === void 0 || _swiperContainer$styl2.call(_swiperContainer$styl, "transform", "translateX(0)");
          swiperContainer === null || swiperContainer === void 0 || (_swiperContainer$styl3 = swiperContainer.style) === null || _swiperContainer$styl3 === void 0 || (_swiperContainer$styl4 = _swiperContainer$styl3.setProperty) === null || _swiperContainer$styl4 === void 0 || _swiperContainer$styl4.call(_swiperContainer$styl3, "transition", "transform 0.3s");
        });
      }
    };
    var gestureOptions = vue.reactive({
      destroyInvisible: true,
      visible: !!visible.value
    });
    gestureRef.value = shared_useGesture_index.useGesture(gestureOptions);
    vue.watch(function () {
      return visible.value;
    }, function (newVal) {
      return gestureOptions.visible = !!newVal;
    });
    vue.watch(function () {
      return [visible.value, swiperItemRefs.value];
    }, function (_ref4) {
      var _ref5 = _slicedToArray__default["default"](_ref4, 2),
        newVisible = _ref5[0],
        newRefs = _ref5[1];
      if (!newVisible) return;
      vue.nextTick(function () {
        var _newRefs$forEach;
        newRefs === null || newRefs === void 0 || (_newRefs$forEach = newRefs.forEach) === null || _newRefs$forEach === void 0 || _newRefs$forEach.call(newRefs, function (item, index) {
          var _gestureRef$value;
          var $el = item.$el;
          (_gestureRef$value = gestureRef.value) === null || _gestureRef$value === void 0 || _gestureRef$value.create($el, {
            onDrag: function onDrag(dragState) {
              return handleDrag(dragState, index);
            },
            onDragEnd: function onDragEnd(dragState) {
              return handleDragEnd(dragState);
            },
            onPinch: function onPinch(pinchState) {
              return handlePinch(pinchState, index);
            }
          }, {
            drag: {
              from: function from() {
                return [state.draggedX, state.draggedY];
              },
              pointer: {
                touch: true
              },
              bounds: function bounds() {
                return {
                  top: -getMaxDraggedY(index),
                  right: getMaxDraggedX(),
                  bottom: getMaxDraggedY(index),
                  left: -getMaxDraggedX()
                };
              }
            },
            pinch: {
              from: function from() {
                return [state.scale, 0];
              },
              pointer: {
                touch: true
              }
            }
          });
        });
      });
    });
    vue.watch(function () {
      return state.scale;
    }, function (newVal) {
      return disabled.value = newVal !== 1;
    });
    vue.onUnmounted(function () {
      clearTimeout(dblTapTimer);
    });
    return _objectSpread(_objectSpread({
      swiperRootRef: swiperRootRef,
      swiperItemRefs: swiperItemRefs,
      rootRef: rootRef,
      disabled: disabled,
      name: name
    }, vue.toRefs(state)), {}, {
      prefix: prefix,
      closeNode: closeNode,
      deleteNode: deleteNode,
      currentIndex: currentIndex,
      imageTransform: imageTransform,
      imageTransitionDuration: imageTransitionDuration,
      visible: visible,
      handleClose: handleClose,
      handleDelete: handleDelete,
      onSwiperChange: onSwiperChange,
      onImgLoad: onImgLoad,
      onTransitionEnd: onTransitionEnd,
      onTransitionStart: onTransitionStart
    });
  }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_t_image = vue.resolveComponent("t-image");
  var _component_t_swiper_item = vue.resolveComponent("t-swiper-item");
  var _component_t_swiper = vue.resolveComponent("t-swiper");
  var _component_t_node = vue.resolveComponent("t-node");
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade"
  }, {
    default: vue.withCtx(function () {
      var _ctx$currentIndex, _ctx$images, _ctx$images2;
      return [_ctx.visible ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        ref: function ref(el) {
          return _ctx.rootRef = el;
        },
        class: vue.normalizeClass("".concat(_ctx.prefix, "-image-viewer"))
      }, [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.name, "__mask")),
        onClick: _cache[0] || (_cache[0] = function ($event) {
          return _ctx.handleClose($event, "overlay");
        })
      }, null, 2), vue.createVNode(_component_t_swiper, {
        ref: "swiperRootRef",
        autoplay: false,
        class: vue.normalizeClass("".concat(_ctx.name, "__content")),
        height: "100vh",
        "default-current": _ctx.currentIndex,
        disabled: _ctx.disabled,
        onChange: _ctx.onSwiperChange
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.images, function (image, index) {
            return vue.openBlock(), vue.createBlock(_component_t_swiper_item, {
              ref_for: true,
              ref: "swiperItemRefs",
              key: index,
              class: vue.normalizeClass("".concat(_ctx.name, "__swiper-item")),
              style: {
                "touch-action": "none"
              }
            }, {
              default: vue.withCtx(function () {
                return [vue.createVNode(_component_t_image, {
                  src: image,
                  style: vue.normalizeStyle("".concat(_ctx.imageTransitionDuration, "; ").concat(index === _ctx.touchIndex ? "transform: ".concat(_ctx.imageTransform) : "transform: matrix(1, 0, 0, 1, 0, 0)")),
                  "on-load": function onLoad(_ref) {
                    var e = _ref.e;
                    return _ctx.onImgLoad(e, index);
                  },
                  onTransitionend: vue.withModifiers(function ($event) {
                    return _ctx.onTransitionEnd(index);
                  }, ["self"]),
                  onTransitionstart: vue.withModifiers(function ($event) {
                    return _ctx.onTransitionStart(index);
                  }, ["self"])
                }, null, 8, ["src", "style", "on-load", "onTransitionend", "onTransitionstart"])];
              }),
              _: 2
            }, 1032, ["class"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["class", "default-current", "disabled", "onChange"]), vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.name, "__nav"))
      }, [_ctx.closeNode ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.name, "__nav-close")),
        onClick: _cache[1] || (_cache[1] = function ($event) {
          return _ctx.handleClose($event, "close-btn");
        })
      }, [vue.createVNode(_component_t_node, {
        content: _ctx.closeNode
      }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.showIndex ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass("".concat(_ctx.name, "__nav-index"))
      }, vue.toDisplayString(Math.min(((_ctx$currentIndex = _ctx.currentIndex) !== null && _ctx$currentIndex !== void 0 ? _ctx$currentIndex : 0) + 1, (_ctx$images = _ctx.images) === null || _ctx$images === void 0 ? void 0 : _ctx$images.length)) + "/" + vue.toDisplayString((_ctx$images2 = _ctx.images) === null || _ctx$images2 === void 0 ? void 0 : _ctx$images2.length), 3)) : vue.createCommentVNode("", true), _ctx.deleteNode ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 2,
        class: vue.normalizeClass("".concat(_ctx.name, "__nav-delete")),
        onClick: _cache[2] || (_cache[2] = function () {
          return _ctx.handleDelete && _ctx.handleDelete.apply(_ctx, arguments);
        })
      }, [vue.createVNode(_component_t_node, {
        content: _ctx.deleteNode
      }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)], 2)) : vue.createCommentVNode("", true)];
    }),
    _: 1
  });
}

script.render = render;

exports["default"] = script;
//# sourceMappingURL=image-viewer.js.map
